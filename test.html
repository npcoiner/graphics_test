<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Optimized WebGPU Cube Grid</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; font-family: monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="gfx"></canvas>
    <script>
// Optimized WebGPU cube grid demo
// ===============================
async function initWebGPU() {
const canvas = document.getElementById('gfx');

// Create stats display
const stats = document.createElement('div');
Object.assign(stats.style, {
  position: 'fixed', top: '6px', left: '6px', zIndex: 1e4,
  background: 'rgba(0,0,0,.8)', color: '#fff', fontFamily: 'monospace', 
  padding: '8px 12px', borderRadius: '4px', fontSize: '12px'
});
document.body.appendChild(stats);

// Create control panel
const panel = document.createElement('div');
Object.assign(panel.style, {
  position: 'fixed', bottom: '10px', left: '10px', background: 'rgba(0,0,0,.8)',
  color: '#fff', padding: '12px', fontFamily: 'monospace', zIndex: 1e4,
  borderRadius: '4px', fontSize: '12px'
});
document.body.appendChild(panel);

const slider = Object.assign(document.createElement('input'), { type: 'range', min: 1, max: 25, value: 8 });
const sizeLabel = document.createElement('span'); 
sizeLabel.textContent = slider.value;
panel.append('Grid Size: ', slider, ' ', sizeLabel, document.createElement('br'));

const depthChk = Object.assign(document.createElement('input'), { type: 'checkbox', checked: true });
panel.append(depthChk, ' Depth Test ', document.createElement('br'));

const cullChk = Object.assign(document.createElement('input'), { type: 'checkbox', checked: true });
panel.append(cullChk, ' Backface Culling');

// Parameters
let gridSize = +slider.value;
let numInstances = gridSize ** 3;
let depthEnabled = depthChk.checked;
let cullEnabled = cullChk.checked;
let needsPipelineRebuild = false;

// WebGPU setup
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext('webgpu');
const format = navigator.gpu.getPreferredCanvasFormat();
const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap DPR for performance

let depthTexture;

function resize() {
  canvas.width = Math.floor(canvas.clientWidth * dpr);
  canvas.height = Math.floor(canvas.clientHeight * dpr);
  context.configure({ device, format, alphaMode: 'opaque' });
  
  // Recreate depth texture
  if (depthTexture) depthTexture.destroy();
  depthTexture = device.createTexture({
    size: [canvas.width, canvas.height],
    format: 'depth24plus',
    usage: GPUTextureUsage.RENDER_ATTACHMENT
  });
}

resize();
window.addEventListener('resize', resize);

// Create buffers
function createBuffer(data, usage) {
  const buffer = device.createBuffer({
    size: data.byteLength,
    usage,
    mappedAtCreation: true
  });
  
  if (usage & GPUBufferUsage.INDEX) {
    new Uint16Array(buffer.getMappedRange()).set(data);
  } else {
    new Float32Array(buffer.getMappedRange()).set(data);
  }
  
  buffer.unmap();
  return buffer;
}

// Cube geometry
const cubeVertices = new Float32Array([
  // Front face
  -0.5, -0.5,  0.5,   0.5, -0.5,  0.5,   0.5,  0.5,  0.5,  -0.5,  0.5,  0.5,
  // Back face  
  -0.5, -0.5, -0.5,  -0.5,  0.5, -0.5,   0.5,  0.5, -0.5,   0.5, -0.5, -0.5,
  // Top face
  -0.5,  0.5, -0.5,  -0.5,  0.5,  0.5,   0.5,  0.5,  0.5,   0.5,  0.5, -0.5,
  // Bottom face
  -0.5, -0.5, -0.5,   0.5, -0.5, -0.5,   0.5, -0.5,  0.5,  -0.5, -0.5,  0.5,
  // Right face
   0.5, -0.5, -0.5,   0.5,  0.5, -0.5,   0.5,  0.5,  0.5,   0.5, -0.5,  0.5,
  // Left face
  -0.5, -0.5, -0.5,  -0.5, -0.5,  0.5,  -0.5,  0.5,  0.5,  -0.5,  0.5, -0.5
]);

const cubeIndices = new Uint16Array([
   0,  1,  2,   0,  2,  3,    // front
   4,  5,  6,   4,  6,  7,    // back
   8,  9, 10,   8, 10, 11,    // top
  12, 13, 14,  12, 14, 15,    // bottom
  16, 17, 18,  16, 18, 19,    // right
  20, 21, 22,  20, 22, 23     // left
]);

const vertexBuffer = createBuffer(cubeVertices, GPUBufferUsage.VERTEX);
const indexBuffer = createBuffer(cubeIndices, GPUBufferUsage.INDEX);

// Uniform buffers - separate for better cache performance
const cameraBuffer = device.createBuffer({
  size: 144, // mat4 viewProj (64) + mat4 view (64) + vec4 cameraPos (16) = 144 bytes
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const sceneBuffer = device.createBuffer({
  size: 16, // vec4 with gridSize, spacing, time, padding (16 bytes total)
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

// Optimized shader with uniforms instead of constants
const shaderCode = `
struct CameraUniforms {
  viewProj: mat4x4<f32>,
  view: mat4x4<f32>,
  position: vec4<f32>,
};

struct SceneUniforms {
  gridSize: f32,
  spacing: f32,
  time: f32,
  _padding: f32,
};

@group(0) @binding(0) var<uniform> camera: CameraUniforms;
@group(0) @binding(1) var<uniform> scene: SceneUniforms;

struct VertexInput {
  @location(0) position: vec3<f32>,
  @builtin(instance_index) instanceIndex: u32,
};

struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) color: vec3<f32>,
};

@vertex fn vs_main(input: VertexInput) -> VertexOutput {
  var output: VertexOutput;
  
  let gridSize = u32(scene.gridSize);
  let spacing = scene.spacing;
  
  // Calculate 3D grid position from 1D instance index
  let x = input.instanceIndex % gridSize;
  let y = (input.instanceIndex / gridSize) % gridSize;
  let z = input.instanceIndex / (gridSize * gridSize);
  
  // Center the grid around origin
  let gridOffset = vec3<f32>(
    f32(x) - f32(gridSize - 1u) * 0.5,
    f32(y) - f32(gridSize - 1u) * 0.5,
    f32(z) - f32(gridSize - 1u) * 0.5
  ) * spacing;
  
  // Simple world position
  let worldPos = input.position + gridOffset;
  output.position = camera.viewProj * vec4<f32>(worldPos, 1.0);
  
  // Different colors based on position
  output.color = vec3<f32>(
    f32(x) / f32(gridSize - 1u),
    f32(y) / f32(gridSize - 1u), 
    f32(z) / f32(gridSize - 1u)
  );
  
  return output;
}

@fragment fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
  return vec4<f32>(input.color, 1.0);
}
`;

const shaderModule = device.createShaderModule({ code: shaderCode });

// Pipeline and bind group
let pipeline, bindGroup;

function createPipeline() {
  const pipelineDescriptor = {
    layout: 'auto',
    vertex: {
      module: shaderModule,
      entryPoint: 'vs_main',
      buffers: [{
        arrayStride: 12, // 3 floats * 4 bytes
        attributes: [{
          shaderLocation: 0,
          format: 'float32x3',
          offset: 0
        }]
      }]
    },
    fragment: {
      module: shaderModule,
      entryPoint: 'fs_main',
      targets: [{ format }]
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: cullEnabled ? 'back' : 'none'
    }
  };
  
  if (depthEnabled) {
    pipelineDescriptor.depthStencil = {
      format: 'depth24plus',
      depthWriteEnabled: true,
      depthCompare: 'less'
    };
  }
  
  pipeline = device.createRenderPipeline(pipelineDescriptor);
  
  bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: cameraBuffer } },
      { binding: 1, resource: { buffer: sceneBuffer } }
    ]
  });
}

createPipeline();

// Event handlers
slider.oninput = () => {
  gridSize = +slider.value;
  sizeLabel.textContent = slider.value;
  numInstances = gridSize ** 3;
};

depthChk.onchange = () => {
  depthEnabled = depthChk.checked;
  needsPipelineRebuild = true;
};

cullChk.onchange = () => {
  cullEnabled = cullChk.checked;
  needsPipelineRebuild = true;
};

// Matrix utilities
function createPerspectiveMatrix(fovy, aspect, near, far) {
  const f = 1.0 / Math.tan(fovy / 2);
  return new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) / (near - far), -1,
    0, 0, (2 * far * near) / (near - far), 0
  ]);
}

function createLookAtMatrix(eye, center, up) {
  const zAxis = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
  const xAxis = normalize(cross(up, zAxis));
  const yAxis = cross(zAxis, xAxis);
  
  return new Float32Array([
    xAxis[0], yAxis[0], zAxis[0], 0,
    xAxis[1], yAxis[1], zAxis[1], 0,
    xAxis[2], yAxis[2], zAxis[2], 0,
    -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
  ]);
}

function normalize(v) {
  const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  return len > 0 ? [v[0] / len, v[1] / len, v[2] / len] : [0, 0, 0];
}

function cross(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0]
  ];
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function multiplyMatrices(a, b) {
  const result = new Float32Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      result[i * 4 + j] = 
        a[i * 4 + 0] * b[0 * 4 + j] +
        a[i * 4 + 1] * b[1 * 4 + j] +
        a[i * 4 + 2] * b[2 * 4 + j] +
        a[i * 4 + 3] * b[3 * 4 + j];
    }
  }
  return result;
}

// Animation loop
let lastTime = 0;
let frameCount = 0;
let lastFpsUpdate = 0;

function animate(currentTime) {
  if (!lastTime) lastTime = currentTime; // Initialize lastTime
  const deltaTime = currentTime - lastTime;
  lastTime = currentTime;
  frameCount++;
  
  // Update FPS counter
  if (currentTime - lastFpsUpdate >= 1000) {
    const fps = (frameCount * 1000) / (currentTime - lastFpsUpdate);
    stats.textContent = `FPS: ${fps.toFixed(1)} | Cubes: ${numInstances.toLocaleString()} | Draw Calls: 1`;
    frameCount = 0;
    lastFpsUpdate = currentTime;
  }
  
  // Rebuild pipeline if needed
  if (needsPipelineRebuild) {
    createPipeline();
    needsPipelineRebuild = false;
  }
  
  // Very simple static camera - close up view
  const cameraPos = [5, 5, 10];
  
  const aspect = canvas.width / canvas.height;
  const projMatrix = createPerspectiveMatrix(Math.PI / 3, aspect, 0.1, 100);
  const viewMatrix = createLookAtMatrix(cameraPos, [0, 0, 0], [0, 1, 0]);
  const viewProjMatrix = multiplyMatrices(projMatrix, viewMatrix);
  
  // Update camera uniform buffer
  const cameraData = new Float32Array(36); // 144 bytes / 4 = 36 floats
  cameraData.set(viewProjMatrix, 0);  // 16 floats
  cameraData.set(viewMatrix, 16);     // 16 floats  
  cameraData.set([cameraPos[0], cameraPos[1], cameraPos[2], 1.0], 32); // 4 floats (vec4)
  device.queue.writeBuffer(cameraBuffer, 0, cameraData);
  
  // Update scene uniform buffer
  const sceneData = new Float32Array([
    gridSize,     // gridSize
    1.0,          // spacing - reduced from 2.0
    currentTime,  // time
    0.0           // padding
  ]);
  device.queue.writeBuffer(sceneBuffer, 0, sceneData);
  
  // Render
  const commandEncoder = device.createCommandEncoder();
  const renderPassDescriptor = {
    colorAttachments: [{
      view: context.getCurrentTexture().createView(),
      clearValue: { r: 0.05, g: 0.05, b: 0.1, a: 1.0 },
      loadOp: 'clear',
      storeOp: 'store'
    }]
  };
  
  if (depthEnabled) {
    renderPassDescriptor.depthStencilAttachment = {
      view: depthTexture.createView(),
      depthClearValue: 1.0,
      depthLoadOp: 'clear',
      depthStoreOp: 'store'
    };
  }
  
  const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
  renderPass.setPipeline(pipeline);
  renderPass.setBindGroup(0, bindGroup);
  renderPass.setVertexBuffer(0, vertexBuffer);
  renderPass.setIndexBuffer(indexBuffer, 'uint16');
  renderPass.drawIndexed(cubeIndices.length, numInstances);
  renderPass.end();
  
  device.queue.submit([commandEncoder.finish()]);
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
}

// Initialize WebGPU when page loads
initWebGPU().catch(error => {
  console.error('WebGPU initialization failed:', error);
  document.body.innerHTML = '<div style="color: white; padding: 20px; font-family: monospace;">WebGPU not supported or failed to initialize. Please use a browser that supports WebGPU.</div>';
});
    </script>
</body>
</html>
